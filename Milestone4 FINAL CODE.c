#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    irsensor1,      sensorReflection)
#pragma config(Sensor, in2,    irsensor2,      sensorReflection)
#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  button2,        sensorTouch)
#pragma config(Sensor, dgtl3,  button3,        sensorTouch)
#pragma config(Sensor, dgtl4,  button4,        sensorTouch)
#pragma config(Sensor, dgtl5,  sonar1,         sensorSONAR_cm)
#pragma config(Sensor, dgtl7,  piezobuzzer,    sensorDigitalOut)
#pragma config(Sensor, dgtl10, led1,           sensorDigitalOut)
#pragma config(Sensor, dgtl11, led2,           sensorDigitalOut)
#pragma config(Sensor, dgtl12, led3,           sensorDigitalOut)
#pragma config(Sensor, I2C_1,  motor1,         sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           motor1,        tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           motor3,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           buzzer,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          motor2,        tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define task_number 1

bool button1_pushed; //flag to store button1 input this is the left button
bool button2_pushed; //flag to store button2 input this is the right button
bool button3_pushed; //flag to store button3 input this is the left bumper switch
bool button4_pushed; //flag to store button4 input this is the right bumper switch
float sonar1_value; //flag to store sonar sensor value in cm
int irsensor1_value; //flag to store value of left IR phototransistor
int irsensor2_value; //flag to store value of right IR phototransistor
int irdiff; // absolute value of difference of irsensors
bool beacon; // sees beacon if this is true
bool wall; // is facing a wall and is too close if true
bool nearbeacon; //is close enough to beacon to connect
int led_1; //controlls 1st led
int led_2; //controlls 2nd led
int led_3; //controlls 3rd led
int walld; //indicator of which side wall was encountered on, 1 is forward, 2 is left, 3 is right
int walldetect; //flag if wall is detected
int hz10adjust; //output of the monitorLight function, this value is the level of IR light adjusted for the 10hz
const int irthreshold = 50; //adjust this it is too sensitive right now
bool searchloop = true; //flag used to loop between the two search states
int irbalance = 0; // value which is assigned by the balanceLight function that determines which side of the robot the IR beacon was last seen
static int irbalance1 = 0; //this value is used withint the balanceLight function


int monitorLight() //code that adjusts for the 10hz frequency of the IR transistor
{
	// Static variables are a special class of variables that maintain
	// their values between subsequent calls to a function.  The intialization
	// values are only stored in the variables when the function is first called.
	// After that, the values that were in the variable at the end of the last time
	// the function is called will be stored in the variable when the function
	// execution is started.
	static int minLevelIR1 = 4096;	// Minimum light level seen by IR sensor 1
	static int maxLevelIR1 = 0;			// Maximum light level seen by IR sensor 1
	static int diffLevelIR1 = 0;		// Delta between maximum and minimum seen in last 0.1 seconds

	int lightLevel1 = (irsensor1_value + irsensor2_value)/2;
	//int lightLevel1 = SensorValue[irsensor1];

	// Check if 100 msecs have elapsed.
	if ( time1[T1] > 100 )  {

		// 100 msecs have elapsed.  Compute delta of light level.
		diffLevelIR1 = maxLevelIR1 - minLevelIR1;

		// Reset calculation for next 100 msecs.
		maxLevelIR1 = 0;
		minLevelIR1 = 4096;
		clearTimer(T1);

		} else {

		// Check for new minimum/maximum light levels.
		if ( lightLevel1 < minLevelIR1 ) {
			minLevelIR1 = lightLevel1;
			} else if ( lightLevel1 > maxLevelIR1 ) {
			maxLevelIR1 = lightLevel1;
		}
	}

	return(diffLevelIR1);
}

int balanceLight() //code that determines which side of the front of the robot the IR beacon was last seen on
{
	// Static variables are a special class of variables that maintain
	// their values between subsequent calls to a function.  The intialization
	// values are only stored in the variables when the function is first called.
	// After that, the values that were in the variable at the end of the last time
	// the function is called will be stored in the variable when the function
	// execution is started.
	static int minLevelIR1 = 4096;	// Minimum light level seen by IR sensor 1
	static int maxLevelIR1 = 0;			// Maximum light level seen by IR sensor 1
	static int minLevelIR2 = 4096;	// Minimum light level seen by IR sensor 2
	static int maxLevelIR2 = 0;			// Maximum light level seen by IR sensor 2

	int lightLevel1 = (irsensor1_value);
	int lightLevel2 = (irsensor2_value);
	//int lightLevel1 = SensorValue[irsensor1];

	// Check if 100 msecs have elapsed.
	if ( time1[T1] > 100 )  {
		irbalance1 = 3; // this is here to see if the code is working. if this funtion returns 3 it is not working

		// 100 msecs have elapsed.  Compute delta of light level.
 		if ((maxLevelIR1 - minLevelIR1) > ((maxLevelIR2 - minLevelIR2)-15)) {
 			irbalance1 = 1;
 	  }
 	  if ((maxLevelIR1 - minLevelIR1) < ((maxLevelIR2 - minLevelIR2)-15)) {
 			irbalance1 = 2;
 	  }
		//diffLevelIR1 = maxLevelIR1 - minLevelIR1;

		// Reset calculation for next 100 msecs.
		maxLevelIR1 = 0;
		minLevelIR1 = 4096;
		maxLevelIR2 = 0;
		minLevelIR2 = 4096;
		clearTimer(T1);

		} else {

		// Check for new minimum/maximum light levels.
		if ( lightLevel1 < minLevelIR1 ) {
			minLevelIR1 = lightLevel1;
			} else if ( lightLevel1 > maxLevelIR1 ) {
			maxLevelIR1 = lightLevel1;
		}
		if ( lightLevel2 < minLevelIR2 ) {
			minLevelIR2 = lightLevel2;
			} else if ( lightLevel2 > maxLevelIR2 ) {
			maxLevelIR2 = lightLevel2;
		}
	}

	return(irbalance1);
}

void walldetection() //function to set the wall detection flags if the wall bumpers have been pressed
{
	if(button3_pushed == true){
		walld = 2; //flag indicating that the wall was detected on the left
		walldetect = 1; //flag if wall is detected
		button1_pushed = false; //clearing button flags, this is done with clearbuttons function elsewhere
		button2_pushed = false;
		button3_pushed = false;
		button4_pushed = false;
	}
	if(button4_pushed == true){
		walld = 3; //flag indicating that the wall was detected on the right
		walldetect = 1;//flag if wall is detected
		button1_pushed = false;//clearing button flags, this is done with clearbuttons function elsewhere
		button2_pushed = false;
		button3_pushed = false;
		button4_pushed = false;
	}
}
void clearbuttons() //this function clears the button pressed flags for the start, stop, and left and right wall detection buttons
{
	button1_pushed = false;
	button2_pushed = false;
	button3_pushed = false;
	button4_pushed = false;
}
void monitorInput() //this function runs often to update various flags and values
{
	sonar1_value = SensorValue(sonar1); //this updates the sonar value from the sonar sensor
	irsensor1_value = SensorValue(irsensor1); //these two update the irsensor valus from the phototransistors
	irsensor2_value = SensorValue(irsensor2);
	irdiff = abs(irsensor1_value - irsensor2_value); //finds the absolute value of the difference between the ir phototransistors
	hz10adjust = monitorLight();//output of the monitorLight function, this value is the level of IR light adjusted for the 10hz
	SensorValue(led1) = led_1;
	SensorValue(led2) = led_2;
	SensorValue(led3) = led_3;
	if(SensorValue(button1) && !button1_pushed)
	{
		button1_pushed = true;
	}

	if(SensorValue(button2) && !button2_pushed)
	{
		button2_pushed = true;
	}
	if(SensorValue(button3) && !button2_pushed)
	{
		button3_pushed = true;
	}
	if(SensorValue(button4) && !button2_pushed)
	{
		button4_pushed = true;
	}
	if(((hz10adjust > irthreshold) && (sonar1_value > 50)) && (sonar1_value!= -1)){ //this is so taht the thershold value is used when the robot is far away from the beacon
		beacon = true;
	}
  if((hz10adjust > (irthreshold+500)) && (sonar1_value < 50)){ //compensation for reflections, a higher threshold value is used when robot is close to the beacon or a wall, to avoid it detecting reflections
		beacon = true;
	}
	if((hz10adjust < irthreshold)&& (sonar1_value > 50)) {
		beacon = false;
	}
	if((hz10adjust < (irthreshold+500))&& ((sonar1_value < 50) && (sonar1_value > -1))) {
		beacon = false;
	}
	if((sonar1_value < 30) && (irsensor1_value > 3200)){
		wall = true;
	}
	if((sonar1_value > 30) && (irsensor1_value > 3200)){
		wall = false;
	}
	if((sonar1_value < 5) && (hz10adjust > irthreshold)){ // this condition lets the robot know that it is within connection range
		nearbeacon = true;
	}
	if(sonar1_value > 3){
		nearbeacon = false;
	}
	if(beacon == true)led_1 = 1; //leds are from milestone 3, used for testing purposes in milestone 4
	if(beacon == false)led_1 = 0;
	if(nearbeacon == true)led_2 = 1;
	if(nearbeacon == false)led_2 = 0;
}


void task_1()
{
	// Define tag for enumerated type for task 1
	enum T_task1_state {
		MOTOR_STOP = 0, //All stop
		SEARCH, //Search in the clockwise direction
		SEARCHCC, //Search in the counterclockwise direction
		FORWARD, //When beacon is found, robot moves towards it
		CONNECT, //When in range of beacon
		WALL_STATE, //If wall is enountered
		WALL_C, //Wall, clockwise rotation if wall is hit on the left
		WALL_CC, //Wall, counterclockwise rotation if wall is hit on the right
		WALL_BACK //Backing up away from wall
	};

	// Declare variable to hold state, intialize to MOTOR_STOP state.
	T_task1_state task1_state = MOTOR_STOP;

	while(true)
	{
		// This function updates the button1_pushed and button2_pushed flags.
		monitorInput();

		// Switch the states.
		switch(task1_state) {

			// Code for MOTOR_STOP state:
		case MOTOR_STOP:
			// Turn motor off.
			motor[motor1] = 0;
			motor[motor2] = 0;
			if (button1_pushed) {

				task1_state = SEARCH;
				// Clear flag to indicate button 1 processed.
				clearbuttons();
				break;
			}
			if (button2_pushed) {
				int releasetimer = 0;
				while (releasetimer < 300){
						motor[motor3]=22;
						releasetimer++;
					}
				motor[motor3]=0;
				clearbuttons();
				break;
			}
			if(button3_pushed) { //buzzer test code
				int timerpiezo = 0;
				while(timerpiezo < 100){
					SensorValue(piezobuzzer) = 1;
					wait1Msec(0.03);
					SensorValue(piezobuzzer) = 0;
					wait1Msec(0.03);
					timerpiezo++;
				}
				clearbuttons();
			}
			if(beacon)irbalance = balanceLight();
			if(irsensor1_value > irsensor2_value) {
				//	irbalance = 1;

			}
			if(irsensor1_value < irsensor2_value) {
				//	irbalance = 2;

			}

			break;
		case CONNECT: //unfinished for milestone 4
			// Turn motor on.
			resetMotorEncoder(motor1);
			resetMotorEncoder(motor2);
			int timerconnect=0;
			while (timerconnect < 3000){
				timerconnect++;
			}
			while(getMotorEncoder(motor1)>=-200){
				motor[motor1]=-30;
				motor[motor2]=-30;
			}
			if(getMotorEncoder(motor1)<=-200){ //victory scream, generates a square wave
				motor[motor1]=0;
				motor[motor2]=0;
				int timerpiezo = 0;
				while(timerpiezo < 600000){
					SensorValue(piezobuzzer) = 1;
					wait1Msec(0.03);
					SensorValue(piezobuzzer) = 0;
					wait1Msec(0.03);
					timerpiezo++;
				}
			}
			resetMotorEncoder(motor1);
			resetMotorEncoder(motor2);
			clearbuttons();
			task1_state = MOTOR_STOP;
			break;
		case FORWARD: //Robot moves towards beacon
			resetMotorEncoder(motor1);
			resetMotorEncoder(motor2);
			while(beacon == true){
				monitorInput();
				monitorLight();
				motor[motor1]=20;
				motor[motor2]=20;
				if ((sonar1_value <30) && (sonar1_value >5)){
					irbalance = balanceLight();
					if(irsensor1_value > irsensor2_value) {
						motor[motor1]=0;
						motor[motor2]=30;
					}
					if(irsensor1_value < irsensor2_value) {
						motor[motor1]=30;
				  	motor[motor2]=0;
				}
				}
				if (nearbeacon == true){
					task1_state = CONNECT;
					break;
				}
				if(beacon)irbalance = balanceLight();
//				if(irsensor1_value > irsensor2_value) {
//					irbalance = 1;

//				}
//				if(irsensor1_value < irsensor2_value) {
//					irbalance = 2;

//				}
			}
			if (nearbeacon == true){
				task1_state = CONNECT;
				break;
			}
			if ((nearbeacon == false) && (irbalance == 1)){
				task1_state = SEARCHCC;
				break;
			}
			if ((nearbeacon == false) && (irbalance == 2)){
				task1_state = SEARCH;
				break;
			}
			clearbuttons();
			break;
		case SEARCH:
			resetMotorEncoder(motor1);
			resetMotorEncoder(motor2);
			monitorInput();
			searchloop = true;
			while(getMotorEncoder(motor1)<=500){
				motor[motor1]=22;
				motor[motor2]=-22;
				monitorInput();
				if(beacon == true){
					task1_state = FORWARD;
					searchloop = false;
					break;
				}
				// Start of wall detection and stop button
				if(button2_pushed == true){
					task1_state = MOTOR_STOP;
					searchloop = false;
					break;
				}
				walldetection();
				if(walldetect == 1){
					task1_state = WALL_STATE;
					walldetect = 0;
					searchloop = false;
					break;
				}
				//end of wall detection and stop button
			}
			if(button2_pushed == true){
				task1_state = MOTOR_STOP;
				searchloop = false;
				break;
			}
			if(searchloop){
				task1_state = SEARCHCC;
				break;
			}
			clearbuttons();
			// task1_state = MOTOR_STOP;
			break;
		case SEARCHCC:
			resetMotorEncoder(motor1);
			resetMotorEncoder(motor2);
			monitorInput();
			searchloop = true;
			while(getMotorEncoder(motor1)>=-1000){ //was 1335 but that caused too much rotation
				motor[motor1]=-22;
				motor[motor2]=22;
				monitorInput();
				if(beacon == true){
					task1_state = FORWARD;
					searchloop = false;
					break;
				}
				// Start of wall detection and stop button
				if(button2_pushed == true){
					task1_state = MOTOR_STOP;
					searchloop = false;
					break;
				}
				walldetection(); //This code is checking if a wall is detected and changes to the wall avoidance state if it does.
				if(walldetect == 1){
					task1_state = WALL_STATE;
					walldetect = 0;
					searchloop = false;
					break;
				}
				//end of wall detection and stop button
			}
			if(button2_pushed == true){
				task1_state = MOTOR_STOP;
				searchloop = false;
				break;
			}
			if(searchloop){
				task1_state = SEARCH;
				break;
			}
			break;
		case WALL_STATE:
			resetMotorEncoder(motor1);
			resetMotorEncoder(motor2);
			if(walld == 2){ //if left bumper hits wall robot will turn 90 degrees and back up CC
				task1_state = WALL_CC;
				walld = 0;
				walldetect = 0;
				break;
			}
			if(walld == 3){ //if right bumber hits wall robot will turn 90 degrees and back up C
				task1_state = WALL_C;
				walld = 0;
				walldetect = 0;
				break;
			}
			clearbuttons();
			break;
		case WALL_C:
			resetMotorEncoder(motor1);
			resetMotorEncoder(motor2);
			while(getMotorEncoder(motor1)<=254){
				motor[motor1]=22;
				motor[motor2]=-22;
				monitorInput();
				walldetection(); //This code is checking if a wall is detected and changes to the wall avoidance state if it does.
				if(button2_pushed == true){
					task1_state = MOTOR_STOP;
					break;
				}
				if(walldetect == 1){
					task1_state = WALL_STATE;
					break;
				}
				if(walldetect == 0){
					task1_state = WALL_BACK;
				}
				clearbuttons();
			}
			break;
		case WALL_CC:
			resetMotorEncoder(motor1);
			resetMotorEncoder(motor2);
			while(getMotorEncoder(motor1)>=-254){
				motor[motor1]=-22;
				motor[motor2]=22;
				monitorInput();
				walldetection(); //This code is checking if a wall is detected and changes to the wall avoidance state if it does.
				if(button2_pushed == true){
					task1_state = MOTOR_STOP;
					break;
				}
				if(walldetect == 1){
					task1_state = WALL_STATE;
					break;
				}
				if(walldetect == 0){
					task1_state = WALL_BACK;
				}
				clearbuttons();
			}
			break;
		case WALL_BACK:
			resetMotorEncoder(motor1);
			while(getMotorEncoder(motor1)>=-500){
				motor[motor1]=-22;
				motor[motor2]=-22;
				monitorInput();
				walldetection(); //This code is checking if a wall is detected and changes to the wall avoidance state if it does.
				if(walldetect == 1){
					task1_state = WALL_STATE;
					break;
				}
				if(walldetect == 0){
					task1_state = SEARCH;
				}
				clearbuttons();
			}
			break;
		default:
		}

	}//end while
}

task main()
{
	button1_pushed = button2_pushed = false;

	switch (task_number)
	{
	case 1:
		task_1(); //Searches for beacon, avoids walls, and connects to beacon when found
		break;
		/* case 2:
		task_2(); //unused from previous milestone
		break; */
	default:
	} // end switch

}// end main
