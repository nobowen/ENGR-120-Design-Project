#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    irsensor1,      sensorReflection)
#pragma config(Sensor, in2,    irsensor2,      sensorReflection)
#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  button2,        sensorTouch)
#pragma config(Sensor, dgtl3,  button3,        sensorTouch)
#pragma config(Sensor, dgtl4,  button4,        sensorTouch)
#pragma config(Sensor, dgtl5,  sonar1,         sensorSONAR_cm)
#pragma config(Sensor, dgtl7,  piezobuzzer,    sensorDigitalOut)
#pragma config(Sensor, dgtl10, led1,           sensorDigitalOut)
#pragma config(Sensor, dgtl11, led2,           sensorDigitalOut)
#pragma config(Sensor, dgtl12, led3,           sensorDigitalOut)
#pragma config(Sensor, I2C_1,  motor1,         sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           motor1,        tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           motor3,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           buzzer,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          motor2,        tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define task_number 1

/* for buttons and sensors, it is programed so odd numbers are on the robot's left side,
and even numbers are on the robot's right side
for example, button1 is on the left and button2 is on the right side.

*/

bool button1_pushed; //flag to store button1 input this is the left button
bool button2_pushed; //flag to store button2 input this is the right button
bool button3_pushed; //flag to store button3 input this is the left bumper switch
bool button4_pushed; //flag to store button4 input this is the right bumper switch
float sonar1_value; //flag to store sonar sensor value in cm
int irsensor1_value; //flag to store value of left IR phototransistor
int irsensor2_value; //flag to store value of right IR phototransistor
int irdiff; // absolute value of difference of irsensors
bool beacon; // sees beacon if this is true
bool wall; // is facing a wall and is too close if true
bool nearbeacon; //is close enough to beacon to connect
int led_1; //controlls 1st led
int led_2; //controlls 2nd led
int led_3; //controlls 3rd led
int walld; //indicator of which side wall was encountered on, 1 is forward, 2 is left, 3 is right
int walldetect; //flag if wall is detected
int hz10adjust; //output of the monitorLight function, this value is the level of IR light adjusted for the 10hz
const int irthreshold = 50; //adjust this it is too sensitive right now
bool searchloop = true; //flag used to loop between the two search states
int irbalance = 0; // value which is assigned by the balanceLight function that determines which side of the robot the IR beacon was last seen
static int irbalance1 = 0; //this value is used withint the balanceLight function


int monitorLight() //code that adjusts for the 10hz frequency of the IR transistor
{
	// Static variables are a special class of variables that maintain
	// their values between subsequent calls to a function.  The intialization
	// values are only stored in the variables when the function is first called.
	// After that, the values that were in the variable at the end of the last time
	// the function is called will be stored in the variable when the function
	// execution is started.
	static int minLevelIR1 = 4096;	// Minimum light level seen by IR sensor 1
	static int maxLevelIR1 = 0;			// Maximum light level seen by IR sensor 1
	static int diffLevelIR1 = 0;		// Delta between maximum and minimum seen in last 0.1 seconds

	int lightLevel1 = (irsensor1_value + irsensor2_value)/2;
	//int lightLevel1 = SensorValue[irsensor1];

	// Check if 100 msecs have elapsed.
	if ( time1[T1] > 100 )  {

		// 100 msecs have elapsed.  Compute delta of light level.
		diffLevelIR1 = maxLevelIR1 - minLevelIR1;

		// Reset calculation for next 100 msecs.
		maxLevelIR1 = 0;
		minLevelIR1 = 4096;
		clearTimer(T1);

		} else {

		// Check for new minimum/maximum light levels.
		if ( lightLevel1 < minLevelIR1 ) {
			minLevelIR1 = lightLevel1;
			} else if ( lightLevel1 > maxLevelIR1 ) {
			maxLevelIR1 = lightLevel1;
		}
	}

	return(diffLevelIR1);
}

int balanceLight() //code that determines which side of the front of the robot the IR beacon was last seen on
{
	// Static variables are a special class of variables that maintain
	// their values between subsequent calls to a function.  The intialization
	// values are only stored in the variables when the function is first called.
	// After that, the values that were in the variable at the end of the last time
	// the function is called will be stored in the variable when the function
	// execution is started.
	static int minLevelIR1 = 4096;	// Minimum light level seen by IR sensor 1
	static int maxLevelIR1 = 0;			// Maximum light level seen by IR sensor 1
	static int minLevelIR2 = 4096;	// Minimum light level seen by IR sensor 2
	static int maxLevelIR2 = 0;			// Maximum light level seen by IR sensor 2

	int lightLevel1 = (irsensor1_value);
	int lightLevel2 = (irsensor2_value);
	//int lightLevel1 = SensorValue[irsensor1];

	// Check if 100 msecs have elapsed.
	if ( time1[T1] > 100 )  {
		irbalance1 = 3; // this is here to see if the code is working. if this funtion returns 3 it is not working

		// 100 msecs have elapsed.  Compute delta of light level.
 		if ((maxLevelIR1 - minLevelIR1) > ((maxLevelIR2 - minLevelIR2)-15)) {
 			irbalance1 = 1;
 	  }
 	  if ((maxLevelIR1 - minLevelIR1) < ((maxLevelIR2 - minLevelIR2)-15)) {
 			irbalance1 = 2;
 	  }
		//diffLevelIR1 = maxLevelIR1 - minLevelIR1;

		// Reset calculation for next 100 msecs.
		maxLevelIR1 = 0;
		minLevelIR1 = 4096;
		maxLevelIR2 = 0;
		minLevelIR2 = 4096;
		clearTimer(T1);

		} else {

		// Check for new minimum/maximum light levels.
		if ( lightLevel1 < minLevelIR1 ) {
			minLevelIR1 = lightLevel1;
			} else if ( lightLevel1 > maxLevelIR1 ) {
			maxLevelIR1 = lightLevel1;
		}
		if ( lightLevel2 < minLevelIR2 ) {
			minLevelIR2 = lightLevel2;
			} else if ( lightLevel2 > maxLevelIR2 ) {
			maxLevelIR2 = lightLevel2;
		}
	}

	return(irbalance1);
}

void walldetection() //function to set the wall detection flags if the wall bumpers have been pressed
{
	if(button3_pushed == true){
		walld = 2; //flag indicating that the wall was detected on the left
		walldetect = 1; //flag if wall is detected
		button1_pushed = false; //clearing button flags, this is done with clearbuttons function elsewhere
		button2_pushed = false;
		button3_pushed = false;
		button4_pushed = false;
	}
	if(button4_pushed == true){
		walld = 3; //flag indicating that the wall was detected on the right
		walldetect = 1;//flag if wall is detected
		button1_pushed = false;//clearing button flags, this is done with clearbuttons function elsewhere
		button2_pushed = false;
		button3_pushed = false;
		button4_pushed = false;
	}
}
void clearbuttons() //this function clears the button pressed flags for the start, stop, and left and right wall detection buttons
{
	button1_pushed = false;
	button2_pushed = false;
	button3_pushed = false;
	button4_pushed = false;
}
void monitorInput() //this function runs often to update various flags and values
{
	sonar1_value = SensorValue(sonar1); //this updates the sonar value from the sonar sensor
	irsensor1_value = SensorValue(irsensor1); //these two update the irsensor valus from the phototransistors
	irsensor2_value = SensorValue(irsensor2);
	irdiff = abs(irsensor1_value - irsensor2_value); //finds the absolute value of the difference between the ir phototransistors
	hz10adjust = monitorLight();//output of the monitorLight function, this value is the level of IR light adjusted for the 10hz
	SensorValue(led1) = led_1;
	SensorValue(led2) = led_2;
	SensorValue(led3) = led_3;
	if(SensorValue(button1) && !button1_pushed)
	{
		button1_pushed = true;
	}

	if(SensorValue(button2) && !button2_pushed)
	{
		button2_pushed = true;
	}
	if(SensorValue(button3) && !button2_pushed)
	{
		button3_pushed = true;
	}
	if(SensorValue(button4) && !button2_pushed)
	{
		button4_pushed = true;
	}
	if(((hz10adjust > irthreshold) && (sonar1_value > 50)) && (sonar1_value!= -1)){ //this is so taht the thershold value is used when the robot is far away from the beacon
		beacon = true;
	}
  if((hz10adjust > (irthreshold+500)) && (sonar1_value < 50)){ //compensation for reflections, a higher threshold value is used when robot is close to the beacon or a wall, to avoid it detecting reflections
		beacon = true;
	}
	if((hz10adjust < irthreshold)&& (sonar1_value > 50)) { //negative versions
		beacon = false;
	}
	if((hz10adjust < (irthreshold+500))&& ((sonar1_value < 50) && (sonar1_value > -1))) {
		beacon = false;
	}
	if((sonar1_value < 30) && (irsensor1_value > 3200)){ //wall detected in front of robot, used for testing purposes but unused in milestone 4 test as the robot driving into a wall isn't an issue
		wall = true;
	}
	if((sonar1_value > 30) && (irsensor1_value > 3200)){
		wall = false;
	}
	if((sonar1_value < 5) && (hz10adjust > irthreshold)){ // this condition lets the robot know that it is within connection range
		nearbeacon = true;
	}
	if(sonar1_value > 3){
		nearbeacon = false;
	}
	if(beacon == true)led_1 = 1; //leds are from milestone 3, used for testing purposes in milestone 4
	if(beacon == false)led_1 = 0;
	if(nearbeacon == true)led_2 = 1;
	if(nearbeacon == false)led_2 = 0;
}


void task_1()
{
	// Define tag for enumerated type for task 1
	enum T_task1_state {
		MOTOR_STOP = 0, //All stop
		SEARCH, //Search in the clockwise direction
		SEARCHCC, //Search in the counterclockwise direction
		FORWARD, //When beacon is found, robot moves towards it
		CONNECT, //When in range of beacon
		WALL_STATE, //If wall is enountered
		WALL_C, //Wall, clockwise rotation if wall is hit on the left
		WALL_CC, //Wall, counterclockwise rotation if wall is hit on the right
		WALL_BACK //Backing up away from wall
	};

	// Declare variable to hold state, intialize to MOTOR_STOP state.
	T_task1_state task1_state = MOTOR_STOP;

	while(true)
	{
		// This function updates various flags and sensor states when ran
		monitorInput();

		// Switch the states.
		switch(task1_state) {

			// Code for MOTOR_STOP state:
		case MOTOR_STOP:
			// Turn motor off.
			motor[motor1] = 0;
			motor[motor2] = 0;
			if (button1_pushed) { // when the left button is pushed the robot starts searching for the beacon

				task1_state = SEARCH;
				// Clear flag to indicate button 1 processed.
				clearbuttons();
				break;
			}
			if(button3_pushed) { //buzzer test code
				int timerpiezo = 0;
				while(timerpiezo < 100){
					SensorValue(piezobuzzer) = 1;
					wait1Msec(0.03);
					SensorValue(piezobuzzer) = 0;
					wait1Msec(0.03);
					timerpiezo++;
				}
				clearbuttons();
			}
			if(beacon == true)irbalance = balanceLight();


			break;
		case CONNECT: //when robot is in range of beacon for connection magnet will connect automatically, it backs up and starts buzzing to indicate connection
			// Turn motor on.
			resetMotorEncoder(motor1);
			resetMotorEncoder(motor2);
			int timerconnect=0;
			while (timerconnect < 3000){
				timerconnect++;
			}
			while(getMotorEncoder(motor1)>=-200){ //robot reverses for a bit
				motor[motor1]=-30;
				motor[motor2]=-30;
			}
			if(getMotorEncoder(motor1)<=-200){ //victory scream, generates a square wave fed into a piezoelectic buzzer
				motor[motor1]=0;
				motor[motor2]=0;
				int timerpiezo = 0;
				while(timerpiezo < 600000){
					SensorValue(piezobuzzer) = 1;
					wait1Msec(0.03);
					SensorValue(piezobuzzer) = 0;
					wait1Msec(0.03);
					timerpiezo++;
				}
			}
			resetMotorEncoder(motor1);
			resetMotorEncoder(motor2);
			clearbuttons();
			task1_state = MOTOR_STOP;
			break;
		case FORWARD: //Robot moves towards beacon
			resetMotorEncoder(motor1);
			resetMotorEncoder(motor2);
			while(beacon == true){
				monitorInput();
				monitorLight();
				motor[motor1]=20;
				motor[motor2]=20;
				if ((sonar1_value <30) && (sonar1_value >5)){ //this code helps the robot oriente towards the beacon more when it is close
					irbalance = balanceLight();
					if(irbalance == 1) { //if beacon was last seen on the left it will turn left more and slower because of the 0 value
						motor[motor1]=0;
						motor[motor2]=30;
					}
					if(irbalance == 2) { //if beacon was last seen on the right it will turn right more and slower because of the 0 value
						motor[motor1]=30;
				  	motor[motor2]=0;
				}
				}
				if (nearbeacon == true){ //moves to connect state when beacon is close
					task1_state = CONNECT;
					break;
				}
				if(beacon == true)irbalance = balanceLight(); //updates the beacon on left or right flag only when the beacon is seen to avoid false values
			}
			if (nearbeacon == true){//moves to connect state when beacon is close
				task1_state = CONNECT;
				break;
			}
			if ((nearbeacon == false) && (irbalance == 1)){ //will go to counter clockwise rotation if it lost the beacon and it was last seen on the left
				task1_state = SEARCHCC;
				break;
			}
			if ((nearbeacon == false) && (irbalance == 2)){ //will go to clockwise rotation if it lost the beacon and it was last seen on the right
				task1_state = SEARCH;
				break;
			}
			clearbuttons();
			break;
		case SEARCH: //Clockwise rotation search
			resetMotorEncoder(motor1);
			resetMotorEncoder(motor2);
			monitorInput();
			searchloop = true; //This remains true until the beacon is found, it is a flag that keeps the robot switching between SEARCH and SEARCHCC, or clockwise and counterclockwise search states
			while(getMotorEncoder(motor1)<=500){
				motor[motor1]=22;
				motor[motor2]=-22;
				monitorInput();
				if(beacon == true){ //when the beacon is found moves to FORWARD state
					task1_state = FORWARD;
					searchloop = false;//breaks the search pattern loop
					break;
				}
				// Start of wall detection and stop button
				if(button2_pushed == true){
					task1_state = MOTOR_STOP;
					searchloop = false;
					break;
				}
				walldetection(); //This code is checking if a wall is detected and changes to the wall avoidance state if it does.
				if(walldetect == 1){
					task1_state = WALL_STATE;
					walldetect = 0;
					searchloop = false;
					break;
				}
				//end of wall detection and stop button
			}
			if(button2_pushed == true){//emergency stop button
				task1_state = MOTOR_STOP;
				searchloop = false;
				break;
			}
			if(searchloop){
				task1_state = SEARCHCC; //moves to counter clockwise state if beacon not found
				break;
			}
			clearbuttons();
			// task1_state = MOTOR_STOP;
			break;
		case SEARCHCC: //counter clockwise rotation search
			resetMotorEncoder(motor1);
			resetMotorEncoder(motor2);
			monitorInput();
			searchloop = true;
			while(getMotorEncoder(motor1)>=-1000){ //was 1335 but that caused too much rotation
				motor[motor1]=-22;
				motor[motor2]=22;
				monitorInput();
				if(beacon == true){//when the beacon is found moves to FORWARD state
					task1_state = FORWARD;
					searchloop = false; //breaks the search pattern loop
					break;
				}
				// Start of wall detection and stop button
				if(button2_pushed == true){
					task1_state = MOTOR_STOP;
					searchloop = false;
					break;
				}
				walldetection(); //This code is checking if a wall is detected and changes to the wall avoidance state if it does.
				if(walldetect == 1){
					task1_state = WALL_STATE;
					walldetect = 0;
					searchloop = false;
					break;
				}
				//end of wall detection and stop button
			}
			if(button2_pushed == true){ //emergency stop button
				task1_state = MOTOR_STOP;
				searchloop = false;
				break;
			}
			if(searchloop){
				task1_state = SEARCH; //moves to clockwise rotation if beacon not found
				break;
			}
			break;
		case WALL_STATE: //this state is reached if a wall is encountered, walld determines which side the wall was detected. depending on the value of walld the code will move to rotate in teh direction away from the wall
			resetMotorEncoder(motor1);
			resetMotorEncoder(motor2);
			if(walld == 2){ //if left bumper hits wall robot will turn 90 degrees counter clockwise and back up
				task1_state = WALL_CC;
				walld = 0;
				walldetect = 0;
				break;
			}
			if(walld == 3){ //if right bumber hits wall robot will turn 90 degrees clockwise and back up C
				task1_state = WALL_C;
				walld = 0;
				walldetect = 0;
				break;
			}
			clearbuttons();
			break;
		case WALL_C: //a clockwise rotation to mvoe away from a wall
			resetMotorEncoder(motor1);
			resetMotorEncoder(motor2);
			while(getMotorEncoder(motor1)<=254){ //roughly 90 degrees
				motor[motor1]=22;
				motor[motor2]=-22;
				monitorInput();
				walldetection(); //This code is checking if a wall is detected and changes to the wall avoidance state if it does.
				if(button2_pushed == true){//emergency stop button
					task1_state = MOTOR_STOP;
					break;
				}
				if(walldetect == 1){ //if wall is found during this rotation break and go to initial wall avoidance state
					task1_state = WALL_STATE;
					break;
				}
				if(walldetect == 0){ // if no wall is found during this rotation move to backing up from wall state
					task1_state = WALL_BACK;
				}
				clearbuttons();
			}
			break;
		case WALL_CC://a counter clockwise rotation to mvoe away from a wall
			resetMotorEncoder(motor1);
			resetMotorEncoder(motor2);
			while(getMotorEncoder(motor1)>=-254){ //roughly 90 degrees
				motor[motor1]=-22;
				motor[motor2]=22;
				monitorInput();
				walldetection(); //This code is checking if a wall is detected and changes to the wall avoidance state if it does.
				if(button2_pushed == true){//emergency stop button
					task1_state = MOTOR_STOP;
					break;
				}
				if(walldetect == 1){//if wall is found during this rotation break and go to initial wall avoidance state
					task1_state = WALL_STATE;
					break;
				}
				if(walldetect == 0){// if no wall is found during this rotation move to backing up from wall state
					task1_state = WALL_BACK;
				}
				clearbuttons();
			}
			break;
		case WALL_BACK: //this is reached if the rotation away from the wall was succesfull. the robot will now back awaay from the wall giving it enough space to perform its searchpattern
			resetMotorEncoder(motor1);
			while(getMotorEncoder(motor1)>=-500){ //backs up for a bit
				motor[motor1]=-22;
				motor[motor2]=-22;
				monitorInput();
				walldetection(); //This code is checking if a wall is detected and changes to the intial wall avoidance state if it does.
				if(walldetect == 1){
					task1_state = WALL_STATE;
					break;
				}
				if(walldetect == 0){
					task1_state = SEARCH;
				}
				clearbuttons();
			}
			break;
		default:
		}

	}//end while
}

task main()
{
	button1_pushed = button2_pushed = false;

	switch (task_number)
	{
	case 1:
		task_1(); //Searches for beacon, avoids walls, and connects to beacon when found
		break;
		/* case 2:
		task_2(); //unused from previous milestone
		break; */
	default:
	} // end switch

}// end main
