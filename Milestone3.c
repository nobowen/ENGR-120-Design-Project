#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  button2,        sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           motor1,        tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port2,           motor2,        tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define task_number 1

bool button1_pushed; //flag to store button1 input
bool button2_pushed; //flag to store button2 input

void monitorInput()
{
  if(SensorValue(button1) && !button1_pushed)
  {
    button1_pushed = true;
  }

  if(SensorValue(button2) && !button2_pushed)
  {
    button2_pushed = true;
  }
}



void task_1()
{
   // Define tag for enumerated type for task 1
   enum T_task1_state {
       MOTOR_STOP = 0,
       ROBOT_FORWARD,
       ROBOT_TURN90
   };

   // Declare variable to hold state, intialize to MOTOR_STOP state.
   T_task1_state task1_state = MOTOR_STOP;

   while(true)
   {
       // This function updates the button1_pushed and button2_pushed flags.
       monitorInput();

       // Switch the states.
       switch(task1_state) {

           // Code for MOTOR_STOP state:
       case MOTOR_STOP:
           // Turn motor off.
           motor[motor1] = 0;
           motor[motor2] = 0;
           if (button1_pushed) {

               task1_state = ROBOT_FORWARD;
               // Clear flag to indicate button 1 processed.
               button1_pushed = false;
               button2_pushed = false;
           }
           if (button2_pushed) {
               // If button 2 pushed, transition to MOTOR_STOP state.
               task1_state = ROBOT_TURN90;
               // Clear flag to indicate that button 2 processed.
               button1_pushed = false;
               button2_pushed = false;
           }
           break;
       case ROBOT_FORWARD:
           // Turn motor on.
               resetMotorEncoder(motor1);
               resetMotorEncoder(motor2);
               while(getMotorEncoder(motor1)>=-627){
                   motor[motor1]=50;
                   motor[motor2]=50;
               }
               motor[motor1]= 0;
               motor[motor2]= 0;
               resetMotorEncoder(motor1);
               resetMotorEncoder(motor2);
							 button1_pushed = false;
               button2_pushed = false;
           break;
       case ROBOT_TURN90:
       				 resetMotorEncoder(motor1);
               resetMotorEncoder(motor2);
           		 while(getMotorEncoder(motor1)>=-627){
                   motor[motor1]=50;
                   motor[motor2]=-50;
           		 }
				  		 button1_pushed = false;
         		   button2_pushed = false;
          		 break;
       default:
       }

   }//end while
}

void task_2()
{
   // Define tag for enumerated type for task 1
   enum T_task1_state {
       MOTOR_STOP = 0,
       ROBOT_FORWARD,
       ROBOT_DISCONNECT
   };

   // Declare variable to hold state, intialize to MOTOR_STOP state.
   T_task1_state task1_state = MOTOR_STOP;

   while(true)
   {
       // This function updates the button1_pushed and button2_pushed flags.
       monitorInput();

       // Switch the states.
       switch(task1_state) {

           // Code for MOTOR_STOP state:
       case MOTOR_STOP:
           // Turn motor off.
           motor[motor1] = 0;
           motor[motor2] = 0;
           if (button1_pushed) {

               task1_state = ROBOT_FORWARD;
               // Clear flag to indicate button 1 processed.
               button1_pushed = false;
               button2_pushed = false;
           }
           break;
       case ROBOT_FORWARD:
           // Turn motor on.
               resetMotorEncoder(motor1);
               resetMotorEncoder(motor2);
               while(getMotorEncoder(motor1)>=-627){
                   motor[motor1]=50;
                   motor[motor2]=50;
               }
               motor[motor1]= 0;
               motor[motor2]= 0;
               resetMotorEncoder(motor1);
               resetMotorEncoder(motor2);
               task1_state = ROBOT_DISCONNECT;
							 button1_pushed = false;
               button2_pushed = false;
           break;
       case ROBOT_DISCONNECT:
       				 resetMotorEncoder(motor1);
               resetMotorEncoder(motor2);
           		 while(getMotorEncoder(motor1)>=-627){
                   motor[motor1]=-50;
                   motor[motor2]=-50;
           		 }
				  		 button1_pushed = false;
         		   button2_pushed = false;
          		 break;
       default:
       }

   }//end while
}


task main()
{
	button1_pushed = button2_pushed = false;

	switch (task_number)
  {
     case 1:
       task_1(); //forwards with button 1 and 90 degrees button 2
       break;
     case 2:
       task_2(); //cable connection simplified
       break;
     default:
   } // end switch

}// end main
